<?php
/**
 * @file
 *  Contains Unit tests for the RoundRobin Plugin Instance.
 */

namespace Drupal\Tests\tournament_round_robin\Unit\Plugin\Tournament;

use Drupal\Core\DependencyInjection\ContainerBuilder;
use Drupal\Tests\UnitTestCase;
use Drupal\tournament\Entity\Match;
use Drupal\tournament\Entity\MatchResult;
use Drupal\tournament\Entity\Participant;
use Drupal\tournament\Entity\Tournament;
use Drupal\tournament\Entity\TournamentInterface;
use Drupal\tournament\Plugin\TournamentManager;
use Drupal\tournament_round_robin\Plugin\Tournament\RoundRobin;
use Prophecy\Prophecy\ObjectProphecy;
use spec\Prophecy\Prophecy\ObjectProphecySpec;

/**
 * @coversDefaultClass \Drupal\tournament_round_robin\Plugin\Tournament\RoundRobin
 *
 * @group Tournament
 */
class RoundRobinTest extends UnitTestCase {

  /**
   * The Tournament Mock object.
   *
   * @var TournamentInterface|\PHPUnit_Framework_MockObject_MockObject
   */
  protected $tournament;

  /**
   * The Tournament Plugin Mananger
   *
   * @var TournamentManager|ObjectProphecy
   */
  protected $tournamentManager;

  /**
   * The Participant Mock Object
   *
   * @var Participant|\PHPUnit_Framework_MockObject_MockObject
   */
  protected $participant;

  /**
   * An Array of Participant Mock Objects
   *
   * @var Participant[]
   */
  protected $participants;

  /**
   * An array of Match objects.
   *
   * @var Matches[]
   */
  protected $matches;

  /**
   * The System Under Test.
   *
   * @var RoundRobin
   */
  protected $sut;

  /**
   * {@inheritdoc}
   */
  public function setUp() {
    parent::setUp();
  }

  /**
   * Prepares different test methods.
   *
   * @param integer $rounds
   *   Number of rounds to play.
   * @param integer $participants_number
   *   Number of participants to participate.
   */
  public function prepareRoundRobinTests($rounds, $participants_number){
    /** @var \PHPUnit_Framework_MockObject_MockObject $participant */
    $this->tournament = $this->getMockBuilder(Tournament::class)
      ->setMethods(['getParticipants', 'getConfig'])
      ->disableOriginalConstructor()
      ->getMock();

    /** @var \PHPUnit_Framework_MockObject_MockObject $participant */
    $this->participant = $this->getMockBuilder(Participant::class)
      ->setMethods(['id'])
      ->disableOriginalConstructor()
      ->getMock();

    // Mock the tournament entity and pass on the amount of rounds  to
    // the configuration BaseField.
    $this->tournament->expects($this->any())
      ->method('getConfig')
      ->willReturn([
        'rounds' => $rounds,
        'interval' => 60 * 60 * 24 * 7,
        'shuffle' => TRUE,
        'start_time' => (int) $_SERVER['REQUEST_TIME'],
      ]);

  }

  /**
   * Tests if the amount of matches generated by ::generateMatches matches the
   * expected amount of Matches.
   *
   * @covers ::generateMatches
   *
   * @dataProvider getGenerateMatchScenarios
   *
   * @param $rounds
   *  Number of rounds to play.
   *
   * @param $participants_number
   *   Number of participants to play.
   *
   * @param $expected_match_count
   *   Expected amount of matches to be generated.
   */
  public function testGenerateMatches($rounds, $participants_number, $expected_match_count) {

    $this->prepareRoundRobinTests($rounds, $participants_number);

    // The getParticipants method would normally return an array of Participants
    // for the tournament. In this case We use Mocks of the participants.
    // Since the id of the participant is used for the generated match (through
    // the id() method, we need to stub the id() method and make it return
    // the index of the iteration.
    for ($i = 0; $i < $participants_number; $i++) {
      $this->participant->expects($this->at($i))
        ->method('id')
        ->willReturn(1 + $i);
      $this->participants[] = $this->participant;
    }

    $this->tournamentManager = $this->prophesize(TournamentManager::class);
    $this->tournamentManager->getParticipants($this->tournament)->willReturn($this->participants);

    $this->sut = new TestRoundRobin([], '', [], $this->tournamentManager->reveal());

    $this->matches = $this->sut->generateMatches($this->tournament);

    // Assert that the total amount of matches is correct.
    $this->assertEquals($expected_match_count, count($this->matches));

  }

  /**
   * Data provider for testGenerateMatches
   */
  public function getGenerateMatchScenarios() {
    return [
      [
        'rounds' => 1,
        'participants_number' => 4,
        'expected_match_count' => 6,
      ],
      [
        'rounds' => 2,
        'participants_number' => 4,
        'expected_match_count' => 12,
      ],
      [
        'rounds' => 1,
        'participants_number' => 5,
        'expected_match_count' => 10,
      ],
      [
        'rounds' => 2,
        'participants_number' => 5,
        'expected_match_count' => 20,
      ],
    ];

  }


  /**
   * Test MatchProcess
   */
  public function testRoundRobinMatchProcess(){
    $this->prepareRoundRobinTests(2, 4);

    // The getParticipants method would normally return an array of Participants
    // for the tournament. In this case We use Mocks of the participants.
    // Since the id of the participant is used for the generated match (through
    // the id() method, we need to stub the id() method and make it return
    // the index of the iteration.
    for ($i = 0; $i < 4; $i++) {
      $this->participant->expects($this->at($i))
        ->method('id')
        ->willReturn(1 + $i);
      $this->participants[] = $this->participant;
    }

    $this->entityTypeManager = $this->getMockBuilder('\Drupal\Core\Entity\EntityTypeManager')
      ->disableOriginalConstructor()
      ->getMock();

    $this->container = new ContainerBuilder();
    $this->container->set('entity_type.manager', $this->entityTypeManager);
    \Drupal::setContainer($this->container);

    $this->tournamentManager = $this->prophesize(TournamentManager::class);
    $this->tournamentManager->getParticipants($this->tournament)->willReturn($this->participants);

    $this->sut = new RoundRobin([], '', [], $this->tournamentManager->reveal());

    $this->matches = $this->sut->generateMatches($this->tournament);

    /** @var Match $match */
    $match = $this->matches[0];

    $results = $match->getMatchResults();

    /** @var MatchResult $result_A */
    $result_A = $results[0];
    $participant_A = $result_A->get('participant');

    /** @var MatchResult $result_B */
    $result_B = $results[1];

    $participant_B = $result_B->get('participant');



    $this->assertTrue(TRUE);
  }

}
